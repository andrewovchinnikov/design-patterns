# Go

<figure><img src="../../../../../.gitbook/assets/image (11).png" alt=""><figcaption><p>UML диаграмма для примера применения паттерна "Одиночка"</p></figcaption></figure>

Разработка веб-приложения для управления личными финансами. Для обеспечения эффективного доступа к данным о финансах и избежания конфликтов при работе с ними необходимо создать единственный экземпляр класса, отвечающего за работу с финансами.

Решение:

Для решения этой задачи мы можем использовать паттерн "Одиночка" (Singleton) для создания единственного экземпляра класса, отвечающего за работу с финансами. Этот экземпляр будет предоставлять доступ к данным о финансах и выполнять операции над ними.

Например, для класса `FinanceManager`, отвечающего за работу с финансами, паттерн "Одиночка" может быть реализован следующим образом на Go:

{% code overflow="wrap" lineNumbers="true" %}
```go
// Класс FinanceManager, отвечающий за работу с финансами
type FinanceManager struct {
    // Свойство, хранящее текущий баланс счета
    balance float64
    // Свойство, хранящее массив транзакций
    transactions []map[string]interface{}
}

// Приватная переменная, хранящая единственный экземплярр класса FinanceManager
var instance *FinanceManager

// Приватный конструктор, предотвращающий создание экземпляров класса с помощью оператора new
func newFinanceManager() *FinanceManager {
    return &FinanceManager{
        balance: 0,
    }
}

// Статический и публичный метод, возвращающий единственный экземплярр класса FinanceManager
func GetInstance() *FinanceManager {
    // Проверяем, является ли переменная instance равной nil
    if instance == nil {
        // Если да, то создаем новый экземплярр класса FinanceManager и сохраняем его в переменной instance
        instance = newFinanceManager()
    }
    // Возвращаем существующий экземплярр класса FinanceManager
    return instance
}

// Публичный метод, возвращающий текущий баланс счета
func (f *FinanceManager) GetBalance() float64 {
    return f.balance
}

// Публичный метод, добавляющий доход на счет
func (f *FinanceManager) AddIncome(amount float64, description string) {
    // Увеличиваем текущий баланс счета на сумму дохода
    f.balance += amount
    // Добавляем транзакцию в массив транзакций
    f.transactions = append(f.transactions, map[string]interface{}{
        "type":        "income",        // Тип транзакции - доход
        "amount":      amount,          // Сумма транзакции
        "description": description,     // Описание транзакции
        "date":        time.Now().Format("2006-01-02 15:04:05"), // Дата и время транзакции
    })
}

// Публичный метод, добавляющий расход со счета
func (f *FinanceManager) AddExpense(amount float64, description string) {
    // Проверяем, достаточно ли средств на счету для совершения расхода
    if f.balance >= amount {
        // Уменьшаем текущий баланс счета на сумму расхода
        f.balance -= amount
        // Добавляем транзакцию в массив транзакций
        f.transactions = append(f.transactions, map[string]interface{}{
            "type":        "expense", // Тип транзакции - расход
            "amount":      amount,     // Сумма транзакции
            "description": description,  // Описание транзакции
            "date":        time.Now().Format("2006-01-02 15:04:05"), // Дата и время транзакции
        })
    } else {
        // Если средств на счету недостаточно, то выводим сообщение об ошибке
        fmt.Println("Недостаточно средств на счету")
    }
}

// Публичный метод, возвращающий массив транзакций
func (f *FinanceManager) GetTransactions() []map[string]interface{} {
    return f.transactions
}

//usage
// Получаем единственный экземплярр класса FinanceManager
financeManager := GetInstance()
// Добавляем доход на счет
financeManager.AddIncome(10000, "Зарплата")
// Добавляем расходы со счета
financeManager.AddExpense(500, "Еда")
financeManager.AddExpense(2000, "Аренда квартиры")
// Получаем текущий баланс счета
balance := financeManager.GetBalance()
fmt.Println("Баланс:", balance)
// Получаем массив транзакций
transactions := financeManager.GetTransactions()
fmt.Println(transactions)
```
{% endcode %}

В этом примере мы создаем класс `FinanceManager`, который отвечает за работу с финансами. Мы используем паттерн "Одиночка" для создания единственного экземпляра класса `FinanceManager`.

Мы объявляем приватную переменную `instance`, которая будет хранить единственный экземплярр класса. Мы также объявляем приватный конструктор, чтобы предотвратить создание экземпляров класса с помощью оператора `new`.

Метод `GetInstance()` является статическим и публичным, и он используется для получения единственного экземпляра класса `FinanceManager`. В этом методе мы проверяем, является ли переменная `instance` равной `nil`. Если да, то мы создаем новый экземплярр класса `FinanceManager` и сохраняем его в переменной `instance`. В противном случае, мы просто возвращаем существующий экземплярр класса `FinanceManager`.

Методы `GetBalance()`, `AddIncome()`, `AddExpense()` и `GetTransactions()` используются для выполнения операций над финансами.

Надеюсь, этот пример поможет вам лучше понять, как можно использовать паттерн "Одиночка" для работы с финансами в веб-приложении на Go.

Основанием для использования паттерна "Одиночка" в этом кейсе является необходимость обеспечения эффективного доступа к данным о финансах и избежания конфликтов при работе с ними. Если бы мы создавали несколько экземпляров класса `FinanceManager`, то это могло бы привести к конфликтам при работе с финансами и несогласованности данных. Поэтому мы используем паттерн "Одиночка", чтобы гарантировать, что будет создан только один экземпляр класса `FinanceManager`, и все операции над финансами будут выполняться через этот экземпляр.
