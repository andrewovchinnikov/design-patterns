# PHP

<figure><img src="../../../../../.gitbook/assets/image (10).png" alt=""><figcaption><p>UML диаграмма для примера применения паттерна "Одиночка"</p></figcaption></figure>

Разработка веб-приложения для управления личными финансами. Для обеспечения эффективного доступа к данным о финансах и избежания конфликтов при работе с ними необходимо создать единственный экземпляр класса, отвечающего за работу с финансами.

Решение:

Для решения этой задачи мы можем использовать паттерн "Одиночка" (Singleton) для создания единственного экземпляра класса, отвечающего за работу с финансами. Этот экземпляр будет предоставлять доступ к данным о финансах и выполнять операции над ними.

Например, для класса `FinanceManager`, отвечающего за работу с финансами, паттерн "Одиночка" может быть реализован следующим образом на PHP:

{% code overflow="wrap" lineNumbers="true" %}
```php
// Класс FinanceManager, отвечающий за работу с финансами
class FinanceManager {
    // Приватное статическое свойство, хранящее единственный экземплярр класса
    private static $instance = null;
    // Свойство, хранящее текущий баланс счета
    private $balance = 0;
    // Свойство, хранящее массив транзакций
    private $transactions = [];

    // Приватный конструктор, предотвращающий создание экземпляров класса с помощью оператора new
    private function __construct() {}

    // Статический и публичный метод, возвращающий единственный экземплярр класса FinanceManager
    public static function getInstance(): FinanceManager {
        // Проверяем, является ли свойство $instance равным null
        if (self::$instance === null) {
            // Если да, то создаем новый экземплярр класса FinanceManager и сохраняем его в свойстве $instance
            self::$instance = new FinanceManager();
        }
        // Возвращаем существующий экземплярр класса FinanceManager
        return self::$instance;
    }

    // Публичный метод, возвращающий текущий баланс счета
    public function getBalance(): float {
        return $this->balance;
    }

    // Публичный метод, добавляющий доход на счет
    public function addIncome(float $amount, string $description = ''): void {
        // Увеличиваем текущий баланс счета на сумму дохода
        $this->balance += $amount;
        // Добавляем транзакцию в массив транзакций
        $this->transactions[] = [
            'type' => 'income', // Тип транзакции - доход
            'amount' => $amount, // Сумма транзакции
            'description' => $description, // Описание транзакции
            'date' => date('Y-m-d H:i:s') // Дата и время транзакции
        ];
    }

    // Публичный метод, добавляющий расход со счета
    public function addExpense(float $amount, string $description): void {
        // Проверяем, достаточно ли средств на счету для совершения расхода
        if ($this->balance >= $amount) {
            // Уменьшаем текущий баланс счета на сумму расхода
            $this->balance -= $amount;
            // Добавляем транзакцию в массив транзакций
            $this->transactions[] = [
                'type' => 'expense', // Тип транзакции - расход
                'amount' => $amount, // Сумма транзакции
                'description' => $description, // Описание транзакции
                'date' => date('Y-m-d H:i:s') // Дата и время транзакции
            ];
        } else {
            // Если средств на счету недостаточно, то выбрасываем исключение
            throw new Exception('Недостаточно средств на счету');
        }
    }

    // Публичный метод, возвращающий массив транзакций
    public function getTransactions(): array {
        return $this->transactions;
    }
}

//usage
// Получаем единственный экземплярр класса FinanceManager
$financeManager = FinanceManager::getInstance();
// Добавляем доход на счет
$financeManager->addIncome(10000, 'Зарплата');
// Добавляем расходы со счета
$financeManager->addExpense(500, 'Еда');
$financeManager->addExpense(2000, 'Аренда квартиры');
// Получаем текущий баланс счета
$balance = $financeManager->getBalance();
echo 'Баланс: ' . $balance . PHP_EOL;
// Получаем массив транзакций
$transactions = $financeManager->getTransactions();
print_r($transactions);
```
{% endcode %}

В этом примере мы создаем класс `FinanceManager`, который отвечает за работу с финансами. Мы используем паттерн "Одиночка" для создания единственного экземпляра класса `FinanceManager`.

Мы объявляем приватное статическое свойство `$instance`, которое будет хранить единственный экземплярр класса. Мы также объявляем приватный конструктор, чтобы предотвратить создание экземпляров класса с помощью оператора `new`.

Метод `getInstance()` является статическим и публичным, и он используется для получения единственного экземпляра класса `FinanceManager`. В этом методе мы проверяем, является ли свойство `$instance` равным `null`. Если да, то мы создаем новый экземплярр класса `FinanceManager` и сохраняем его в свойстве `$instance`. В противном случае, мы просто возвращаем существующий экземплярр класса `FinanceManager`.

Методы `getBalance()`, `addIncome()`, `addExpense()` и `getTransactions()` используются для выполнения операций над финансами.

Надеюсь, этот пример поможет вам лучше понять, как можно использовать паттерн "Одиночка" для работы с финансами в веб-приложении на PHP.

Основанием для использования паттерна "Одиночка" в этом кейсе является необходимость обеспечения эффективного доступа к данным о финансах и избежания конфликтов при работе с ними. Если бы мы создавали несколько экземпляров класса `FinanceManager`, то это могло бы привести к конфликтам при работе с финансами и несогласованности данных. Поэтому мы используем паттерн "Одиночка", чтобы гарантировать, что будет создан только один экземпляр класса `FinanceManager`, и все операции над финансами будут выполняться через этот экземпляр.
