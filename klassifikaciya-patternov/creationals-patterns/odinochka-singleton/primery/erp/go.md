# Go

<figure><img src="../../../../../.gitbook/assets/image (11).png" alt=""><figcaption><p>UML диаграмма для примера применения паттерна "Одиночка"</p></figcaption></figure>

Наша команда разрабатывает ERP систему для управления бизнес-процессами в средних и крупных компаниях. В рамках разработки нам необходимо решить задачу с управлением настройками пользователей. Наша система должна обеспечивать гибкость и масштабируемость, поэтому мы решили использовать паттерн "Одиночка" (Singleton) для создания единственного экземпляра класса, отвечающего за работу с настройками.

Задача:

Нужно разработать класс `SettingsManager`, который будет отвечать за работу с настройками пользователей. Для этого необходимо реализовать паттерн "Одиночка" для создания единственного экземпляра класса `SettingsManager`. Этот экземпляр будет предоставлять доступ к данным о настройках и выполнять операции над ними.

Почему мы выбрали этот паттерн:

Мы выбрали паттерн "Одиночка" для решения этой задачи, потому что он позволяет нам централизовать управление настройками и избежать конфликтов при работе с ними. Кроме того, мы смогли упростить код и уменьшить количество ошибок, связанных с инициализацией и использованием экземпляров класса.

```go
// Класс SettingsManager, отвечающий за работу с настройками
type SettingsManager struct {
    // Свойство, хранящее массив настроек
    settings map[string]interface{}
}

// Приватная переменная, хранящая единственный экземплярр класса
var instance *SettingsManager

// Приватный конструктор, предотвращающий создание экземпляров класса с помощью оператора new
func newSettingsManager() *SettingsManager {
    return &SettingsManager{
        settings: make(map[string]interface{}),
    }
}

// Статический и публичный метод, возвращающий единственный экземплярр класса SettingsManager
func GetInstance() *SettingsManager {
    // Проверяем, существует ли уже экземплярр класса
    if instance == nil {
        // Если нет, то создаем новый экземплярр класса и сохраняем его в переменной instance
        instance = newSettingsManager()
    }
    // Возвращаем существующий экземплярр класса
    return instance
}

// Публичный метод, добавляющий новую настройку в массив настроек
func (s *SettingsManager) AddSetting(key string, value interface{}) {
    // Добавляем новую настройку в массив настроек
    s.settings[key] = value
}

// Публичный метод, возвращающий значение настройки по ее ключу
func (s *SettingsManager) GetSetting(key string) (interface{}, bool) {
    // Возвращаем значение настройки по ее ключу
    value, ok := s.settings[key]
    return value, ok
}

// Публичный метод, удаляющий настройку из массива настроек по ее ключу
func (s *SettingsManager) DeleteSetting(key string) {
    // Если настройка существует, то удаляем ее из массива настроек
    if _, ok := s.settings[key]; ok {
        delete(s.settings, key)
    }
}

//usage
// Получаем единственный экземплярр класса SettingsManager
settingsManager := GetInstance()
// Добавляем новые настройки в массив настроек
settingsManager.AddSetting("language", "en")
settingsManager.AddSetting("theme", "dark")
// Получаем значение настройки по ее ключу
language, _ := settingsManager.GetSetting("language")
fmt.Println(language) // en
// Удаляем настройку из массива настроек по ее ключу
settingsManager.DeleteSetting("theme")
// Получаем обновленный массив всех настроек
settings := settingsManager.settings
fmt.Println(settings) // map[language:en]
```

В этом примере мы создаем класс `SettingsManager`, который отвечает за работу с настройками. Мы используем паттерн "Одиночка" для создания единственного экземпляра класса `SettingsManager`.

Мы объявляем приватное свойство `settings`, которое будет хранить массив настроек. Мы также объявляем приватную переменную `instance`, которая будет хранить единственный экземплярр класса. Мы объявляем приватный конструктор, чтобы предотвратить создание экземпляров класса с помощью оператора `new`.

Метод `GetInstance()` является статическим и публичным, и он используется для получения единственного экземпляра класса `SettingsManager`. В этом методе мы проверяем, существует ли уже экземплярр класса. Если нет, то создаем новый экземплярр класса и сохраняем его в переменной `instance`. В противном случае, мы просто возвращаем существующий экземплярр класса `SettingsManager`.

Методы `AddSetting()`, `GetSetting()` и `DeleteSetting()` используются для выполнения операций над настройками.

Надеюсь, этот пример поможет вам лучше понять, как можно использовать паттерн "Одиночка" для решения задач, связанных с управлением настройками пользователей в веб-приложении на Go.
