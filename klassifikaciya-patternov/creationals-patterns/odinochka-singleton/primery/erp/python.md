# Python

<figure><img src="../../../../../.gitbook/assets/image (14).png" alt=""><figcaption><p>UML диаграмма для примера применения паттерна "Одиночка"</p></figcaption></figure>

Наша команда разрабатывает ERP систему для управления бизнес-процессами в средних и крупных компаниях. В рамках разработки нам необходимо решить задачу с управлением настройками пользователей. Наша система должна обеспечивать гибкость и масштабируемость, поэтому мы решили использовать паттерн "Одиночка" (Singleton) для создания единственного экземпляра класса, отвечающего за работу с настройками.

Задача:

Нужно разработать класс `SettingsManager`, который будет отвечать за работу с настройками пользователей. Для этого необходимо реализовать паттерн "Одиночка" для создания единственного экземпляра класса `SettingsManager`. Этот экземпляр будет предоставлять доступ к данным о настройках и выполнять операции над ними.

Почему мы выбрали этот паттерн:

Мы выбрали паттерн "Одиночка" для решения этой задачи, потому что он позволяет нам централизовать управление настройками и избежать конфликтов при работе с ними. Кроме того, мы смогли упростить код и уменьшить количество ошибок, связанных с инициализацией и использованием экземпляров класса.

```python
# Класс SettingsManager, отвечающий за работу с настройками
class SettingsManager:
    # Свойство, хранящее массив настроек
    settings = {}

    # Приватное свойство, хранящее единственный экземплярр класса
    _instance = None

    # Приватный конструктор, предотвращающий создание экземпляров класса с помощью оператора new
    def __new__(cls, *args, **kwargs):
        # Проверяем, существует ли уже экземплярр класса
        if cls._instance is None:
            # Если нет, то создаем новый экземплярр класса и сохраняем его в свойстве _instance
            cls._instance = super(SettingsManager, cls).__new__(cls, *args, **kwargs)
        # Возвращаем существующий экземплярр класса
        return cls._instance

    # Статический и публичный метод, возвращающий единственный экземплярр класса SettingsManager
    @staticmethod
    def get_instance():
        return SettingsManager()

    # Публичный метод, добавляющий новую настройку в массив настроек
    def add_setting(self, key: str, value: any):
        # Добавляем новую настройку в массив настроек
        self.settings[key] = value

    # Публичный метод, возвращающий значение настройки по ее ключу
    def get_setting(self, key: str) -> any:
        # Возвращаем значение настройки по ее ключу
        return self.settings.get(key, None)

    # Публичный метод, удаляющий настройку из массива настроек по ее ключу
    def delete_setting(self, key: str):
        # Если настройка существует, то удаляем ее из массива настроек
        if self.settings.get(key, None) is not None:
            del self.settings[key]

#usage
# Получаем единственный экземплярр класса SettingsManager
settings_manager = SettingsManager.get_instance()
# Добавляем новые настройки в массив настроек
settings_manager.add_setting("language", "en")
settings_manager.add_setting("theme", "dark")
# Получаем значение настройки по ее ключу
language = settings_manager.get_setting("language")
print(language) # en
# Удаляем настройку из массива настроек по ее ключу
settings_manager.delete_setting("theme")
# Получаем обновленный массив всех настроек
settings = settings_manager.settings
print(settings) # {"language": "en"}
```

В этом примере мы создаем класс `SettingsManager`, который отвечает за работу с настройками. Мы используем паттерн "Одиночка" для создания единственного экземпляра класса `SettingsManager`.

Мы объявляем приватное свойство `settings`, которое будет хранить массив настроек. Мы также объявляем приватное свойство `_instance`, которое будет хранить единственный экземплярр класса. Мы объявляем приватный конструктор, чтобы предотвратить создание экземпляров класса с помощью оператора `new`.

Метод `__new__()` является приватным и статическим, и он используется для получения единственного экземпляра класса `SettingsManager`. В этом методе мы проверяем, существует ли уже экземплярр класса. Если нет, то создаем новый экземплярр класса и сохраняем его в свойстве `_instance`. В противном случае, мы просто возвращаем существующий экземплярр класса `SettingsManager`.

Метод `get_instance()` является статическим и публичным, и он используется для получения единственного экземпляра класса `SettingsManager`.

Методы `add_setting()`, `get_setting()` и `delete_setting()` используются для выполнения операций над настройками.

Надеюсь, этот пример поможет вам лучше понять, как можно использовать паттерн "Одиночка" для решения задач, связанных с управлением настройками пользователей в веб-приложении на Python.
